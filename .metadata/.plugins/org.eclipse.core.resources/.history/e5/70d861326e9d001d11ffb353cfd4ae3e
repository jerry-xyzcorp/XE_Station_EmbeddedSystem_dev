/*
 * User_CupLidDispenser.c
 *
 *  Created on: 2023. 1. 26.
 *      Author: Ethan
 */
#include "User_CupLidDispenser.h"

extern TIM_HandleTypeDef htim1;

extern UART_HandleTypeDef huart3;
extern UART_HandleTypeDef huart5;
extern UART_HandleTypeDef huart6;



uint8_t dispenser_req_packet[][OFFSET] = {{0x02, 0x01, 0x40, 0x03, 0x44, 0X00, 0X00}, // status check
								  	  	  {0x02, 0x03, 0x41, 0x01, 0x01, 0x03, 0x49}}; // dispatch 1 cup
GPIO_TypeDef* 	SteppingMootor_GPIO_Port[OFFSET] = 	{CupD_STP_GPIO_Port, LidD_STP_GPIO_Port};
uint16_t* 		SteppingMootor_Pin[OFFSET] = 		{Cup_up_Pin, Cup_down_Pin};

GPIO_TypeDef* 	MotorSpeedSensor_GPIO_Port[][OFFSET] = {{Cup_up_GPIO_Port, Cup_down_GPIO_Port},
														{Lid_up_GPIO_Port, Lid_down_GPIO_Port}};
uint16_t* 		MotorSpeedSensor_Pin[][OFFSET] = 		{{Cup_up_Pin, Cup_down_Pin},
														{Lid_up_Pin, Lid_down_Pin}};

bool 	is_detected[][OFFSET] 			= {false,};
bool 	is_detected_flag[][OFFSET] 		= {false,};

bool 	is_running[OFFSET] 				= {false,};

char uartBuf[4000];

uint32_t SteppingMotorTest(void)
{
	// 90 degree rotation test

	sprintf(uartBuf, "ROTATE start!!\n");
	 HAL_UART_Transmit(&huart3, (uint8_t *)uartBuf, strlen(uartBuf), 100);

	controlSteppingMotor(CUP_D, STEPPING_MOTOR_ON, QUARTER, FREQ_FAST);
	HAL_Delay(2000);

	return count;
}

void pulseMaker (uint16_t time)	//delay function in 10us
{
	__HAL_TIM_SET_COUNTER(&htim1, 0);
	while (__HAL_TIM_GET_COUNTER (&htim1) < time);
}

void controlSteppingMotor(uint8_t device_id, bool cmd, uint16_t angle, uint8_t freq)
{
	if(cmd == STEPPING_MOTOR_OFF){
		HAL_GPIO_WritePin(CupD_EN_GPIO_Port, CupD_EN_Pin, GPIO_PIN_RESET); //EN - RESET = disable MOTOR
	}
	else if(cmd == STEPPING_MOTOR_ON){
		HAL_GPIO_WritePin(CupD_EN_GPIO_Port, CupD_EN_Pin, GPIO_PIN_SET); //EN - SET = enable MOTOR

		for(uint16_t step=0; step < angle; step++){
			HAL_GPIO_WritePin(SteppingMootor_GPIO_Port, SteppingMootor_Pin, GPIO_PIN_SET);
			pulseMaker(freq);
			HAL_GPIO_WritePin(SteppingMootor_GPIO_Port, SteppingMootor_Pin, GPIO_PIN_RESET);
			pulseMaker(freq);
			if(is_detected_flag[ID][UP] == false){
				if(HAL_GPIO_ReadPin(MotorSpeedSensor_GPIO_Port[ID][UP], MotorSpeedSensor_Pin[ID][UP])){
					is_detected[ID][UP] = true;
					is_detected_flag[ID][UP] = true;
				}
			}
			if(is_detected_flag[ID][UP] == false){
				if(HAL_GPIO_ReadPin(MotorSpeedSensor_GPIO_Port[ID][UP], MotorSpeedSensor_Pin[ID][UP])){
					is_detected[ID][UP] = true;
					is_detected_flag[ID][UP] = true;
				}
			}


			if(HAL_GPIO_ReadPin(MotorSpeedSensor_GPIO_Port[ID][DOWN], MotorSpeedSensor_Pin[ID][DOWN]))
				is_detected[ID][DOWN] = true;
		}
	}
}
bool rotate(uint8_t device_id, uint8_t target_step)
{
	uint8_t ID = device_id - OFFSET;
	uint8_t cur_step = 0;

	controlSteppingMotor(device_id, STEPPING_MOTOR_ON);
	is_running[ID] = true;

	while(true){
		if(HAL_GPIO_ReadPin(MotorSpeedSensor_GPIO_Port[ID][UP], MotorSpeedSensor_Pin[ID][UP]))
			is_detected[ID][UP] = true;
		if(HAL_GPIO_ReadPin(MotorSpeedSensor_GPIO_Port[ID][DOWN], MotorSpeedSensor_Pin[ID][DOWN]))
			is_detected[ID][DOWN] = true;

		if(is_detected[ID][UP] == true && is_detected[ID][DOWN] == true){
			if(cur_step > target_step)
				break;
			else
				cur_step++;
		}
		HAL_Delay(1);
	}

	is_running[ID] = false;

	// stop motor
	controlSteppingMotor(device_id, STEPPING_MOTOR_OFF);

	HAL_Delay(10);
}
bool motorShutdownAll(void)
{
	for(uint8_t id=0; id<OFFSET; id++)
		controlSteppingMotor(id, STEPPING_MOTOR_OFF);

	return true;
}
uint8_t getStatus_cup_lid_Dispensor(void)
{

	for(uint8_t id=0; id<OFFSET; id++){
		if(is_running[id] == true)
			return RUNNING;
	}
}
bool dispatch(uint8_t device_id)
{
	sendCommand(device_id, dispenser_req_packet[DISPATCH_1_CUP]);
	return true;
}

void sendCommand(uint8_t device_id, uint8_t* req_packet)
{
	// init packet
	// calc checksum
	for(int i=1; i<1+req_packet[1]+1;i++){
		req_packet[6] += req_packet[i];
	}

	// request packet
	HAL_UART_Transmit(&huart5, (uint8_t *)req_packet, sizeof(req_packet), 100);

	// for debug
	HAL_UART_Transmit(&huart3, (uint8_t *)dispenser_req_packet, sizeof(dispenser_req_packet), 100);

}


